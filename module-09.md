# Module 09: Iterators

## Introduction

Trying to access the elements of a container is a *very* common pattern in programming. As such, programming languages often provide generic ways to access those values.

In Rust - as well as others - we have "iterators".

An iterator is a way to access a collection of values sequencially. For example, you could have an iterator over the content of a slice, or over the characters of a string, or over a range of integers.

## General Rules

Any program you turn in should compile using the `cargo` package manager, either with `cargo run` if the subject requires a *program*, or with `cargo test` otherwise. Only dependencies specified in the `allowed dependencies` section are allowed.

Any program you turn in should compile *without warnings* using the `rustc` compiler available on the school's machines without additional options. You are allowed to use attributes to modify lint levels, but you must be able to explain why you did so. You are *not* allowed to use `unsafe` code anywere in your code.

## Exercise 00: `for` an `Iterator`

```txt
turn-in directory:
    ex00/

files to turn in:
    src/main.rs  Cargo.toml

allowed dependencies:

```

In Rust, we like to encode common behaviors with traits. The [`Iterator`] trait is used extensively thoughout the whole standard library. You can take a look at the [`iter`](https://doc.rust-lang.org/std/iter/index.html) module, for some cool examples.

Let's start with something simple. Create a `main` function that showcases multiple `for` loops. You will be asked during defense why the values you are iterating over *can* be iterated over.

Specifically, you must include iterators over multiples containers, such as `Vec<T>`, `&str`, and `HashMap<K, V>`.

## Exercise 01: Three Numbers

```txt
turn-in directory:
    ex01/

files to turn in:
    src/lib.rs  Cargo.toml

allowed dependencies:

```

Create a type named `MyIterator` which implements the [`Iterator`] trait.

The [`Iterator`] implementation of that type should yield tree values of your choice before stopping.

For example:

```Rust
#[test]
fn my_iterator() {
    let mut my_iterator = MyIterator::new();
    assert_eq!(my_iterator.next(), Some(15));
    assert_eq!(my_iterator.next(), Some(2));
    assert_eq!(my_iterator.next(), Some(5));
    assert_eq!(my_iterator.next(), None);
}
```

## Exercise 02: Largest Valid Number

```txt
turn-in directory:
    ex02/

files to turn in:
    src/lib.rs  Cargo.toml

allowed dependencies:

```

If you look at the documentation for [`Iterator`], you'll see that it provides *a lot* of associated functions. Most of those functions are used to create what we call "iterator adaptors".

Create a **function** named `largest_odd_number`. The function takes an `input`, splits it on whitespaces, converts the "words" into numbers (invalid words must be ignored), and returns the largest odd number.

You are *not* allowed to use `for` loops or semicolons `';'` when implementing the function.

```Rust
fn largest_odd_number(input: &str) -> u32;
```

For example:

```Rust
let a = "2   15 4  13";
let b = "42 \t 235\n10 1000";
let c = "1 bonjour 20 au revoir 10"

assert_eq!(largest_odd_number(a), 14);
assert_eq!(largest_odd_number(b), 235);
assert_eq!(largest_odd_number(c), 1);
```

You must provide tests.

## Exercise 03: Collecting Collections

```txt
turn-in directory:
    ex04/

files to turn in:
    src/lib.rs  Cargo.toml

allowed dependencies:

```

An iterator do not have any underlying representation we can rely upon. That is fine, most of the time. But somtimes, we *need* to be able to access the elements of an iterator in a certain way (for example, using indexes).

Without using `for` loops or even semicolons `';'`, implement the `collect_odd_numbers` function. It should roughly work like the `largest_odd_number` of last exercise, but instead of computing the largest number, this function should put the resulting numbers into a `Vec<u32>`.

```Rust
fn collect_odd_numbers(input: &str) -> Vec<u32>;
```

Example:

```Rust
let input = "1  bonjour 20 au revoir 23 test 3"
let vec = collect_odd_numbers(input);

assert_eq!(vec, [1, 23, 3]);
```

You must writ test for this new function.

## Exercise 04: All Prime Numbers

```txt
turn-in directory:
    ex04/

files to turn in:
    src/main.rs  Cargo.toml

allowed dependencies:

```

To finish this short module, create a type named `Primes`. This type must implement the [`Iterator`] trait and yield every prime number that fits within an `u16`. The iterator must *not* panic!

Create a simple **program**. The `main` function should simply consist of a `for` loop to print the numbers generated by your iterator.

```txt
>_ cargo run
2
3
5
7
...
65497
65519
65521
```

## Exercise 05: Increasing Sequence

```txt
turn-in directory:
    ex05/

files to turn in:
    src/lib.rs  Cargo.toml

allowed dependencies:

```

To finish, let's create our own iterator adaptor.

Create a type named `Increasing<I>`. It must be generic over `I`. As long as `I` is an iterator and that the values of that iterator can be compared (they have support for the `<` operator), `Increasing<I>` must also derive [`Iterator`] and returns the values of `I` filtering any non-strictly-increasing value.

For example:

```Rust
let mut iter = Increasing::new([0.4, 0.2, 0.1, 0.2, 0.5, 0.4, 0.6]);

assert_eq!(iter.next(), Some(0.4));
assert_eq!(iter.next(), Some(0.5));
assert_eq!(iter.next(), Some(0.6));
assert_eq!(iter.next(), None);
```

You must provide tests for your iterator. Try to use it with multiple value types and child iterators!.

[`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html
