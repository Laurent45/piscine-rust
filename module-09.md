# Module 09: Iterators

## Introduction

Trying to access the elements of a container is a *very* common pattern in programming. As such,
programming languages often provide generic ways to access those values.

In Rust - as well as others - we have "iterators".

An iterator is a way to access a collection of values sequencially. For example, you could have an
iterator over the content of a slice, or over the characters of a string, or over a range of
integers.

## General Rules

Any program you turn in should compile using the `cargo` package manager, either with `cargo run`
if the subject requires a *program*, or with `cargo test` otherwise. Only dependencies specified
in the `allowed dependencies` section are allowed. Only symbols specified in the `allowed symbols`
section are allowed. Every exercise that uses the `cargo` package manager must be part of a single
virtual Cargo workspace, a single `workspace.members` table must be declared for the whole module.

Any program you turn in should compile *without warnings* using the `rustc` compiler available on
the school's machines without additional options. You are allowed to use attributes to modify lint
levels, but you must be able to explain why you did so. You are *not* allowed to use `unsafe` code
anywere in your code.

## Exercise 00: `for` an `Iterator`

```txt
turn-in directory:
    ex00/

files to turn in:
    src/main.rs  Cargo.toml

allowed dependencies:
    std::*
```

Let's start with something simple. Create a `main` function that showcases multiple `for` loops.
You will be asked during defense why the values you are iterating over *can* be iterated over. In
other words, why can you iterate over `Vec<T>`, but not over `u32`?

Specifically, you must include iterators over multiples containers, such as `Vec<T>`, `&str`, and
`HashMap<K, V>`.

## Exercise 01: Three Numbers

```txt
turn-in directory:
    ex01/

files to turn in:
    src/lib.rs  Cargo.toml

allowed dependencies:
    std::iter::Iterator
```

Create a type named `MyIterator` which implements the `Iterator` trait.

The `Iterator` implementation of that type should yield tree values of your choice before
stopping.

For example:

```rust
#[test]
fn my_iterator() {
    let mut my_iterator = MyIterator::new();
    assert_eq!(my_iterator.next(), Some(15));
    assert_eq!(my_iterator.next(), Some(2));
    assert_eq!(my_iterator.next(), Some(5));
    assert_eq!(my_iterator.next(), None);
}
```

## Exercise 02: Largest Valid Number

```txt
turn-in directory:
    ex02/

files to turn in:
    src/lib.rs  Cargo.toml

allowed symbols:
    std::iter::Iterator  str::*  std::result::Result
```

Create a **function** named `largest_odd_number`. The function takes an `input`, splits it on
whitespaces, converts the "words" into numbers (invalid words must be ignored), and returns the
largest odd number.

You are *not* allowed to use `for` loops or semicolons `';'` when implementing the function.

```rust
fn largest_odd_number(input: &str) -> u32;
```

For example:

```rust
let a = "2   15 4  13";
let b = "42 \t 235\n10 1000";
let c = "1 bonjour 20 au revoir 10"

assert_eq!(largest_odd_number(a), 14);
assert_eq!(largest_odd_number(b), 235);
assert_eq!(largest_odd_number(c), 1);
```

You must provide tests.

## Exercise 03: Collecting Collections

```txt
turn-in directory:
    ex04/

files to turn in:
    src/lib.rs  Cargo.toml

allowed symbols:
    std::iter::Iterator  str::*  std::result::Result
```

Without using `for` loops or even semicolons `';'`, implement the `collect_words_len` function.
This function must produce a `Vec<usize>` containing the length of every word of `input` (words
are separate by whitespace characters).

```rust
fn collect_(input: &str) -> Vec<u32>;
```

Example:

```rust
let input = "1  bonjour 20 au revoir 23    \t test 3"
let vec = collect_words_len(input);

assert_eq!(vec, [1, 7, 2, 2, 6, 2, 4, 1]);
```

You must writ test for this new function.

## Exercise 04: All Prime Numbers

```txt
turn-in directory:
    ex04/

files to turn in:
    src/main.rs  Cargo.toml

allowed symbols:
    std::*
```

To finish this short module, create a type named `Primes`. This type must implement the
`Iterator` trait and yield every prime number that fits within an `u16`. The iterator must *not*
panic!

Create a simple **program**. The `main` function should simply consist of a `for` loop to print the
numbers generated by your iterator.

```rust
fn main() {
    for p in Primes::new() {
        println!("{p}");
    }
}
```

```txt
>_ cargo run
2
3
5
7
...
65497
65519
65521
```

## Exercise 05: Increasing Sequence

```txt
turn-in directory:
    ex05/

files to turn in:
    src/lib.rs  Cargo.toml

allowed symbols:
    std::*
```

To finish, let's create our own iterator adaptor.

Create a type named `Increasing<I>`. It must be generic over `I`. As long as `I` is an iterator and
that the values of that iterator can be compared (they have support for the `<` operator),
`Increasing<I>` must also derive `Iterator` and returns the values of `I` filtering any
non-strictly-increasing value.

For example:

```rust
let mut iter = Increasing::new([0.4, 0.2, 0.1, 0.2, 0.5, 0.4, 0.6]);

assert_eq!(iter.next(), Some(0.4));
assert_eq!(iter.next(), Some(0.5));
assert_eq!(iter.next(), Some(0.6));
assert_eq!(iter.next(), None);
```

You must provide tests for your iterator. Try to use it with multiple value types and child
iterators!.
